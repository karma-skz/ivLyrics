const VideoBackground = ({ trackUri, firstLyricTime, brightness, blurAmount, coverMode, externalVideoInfo }) => {
    const { useState, useEffect, useRef, useCallback } = react;
    const [videoInfo, setVideoInfo] = useState(null);
    const [isPlayerReady, setIsPlayerReady] = useState(false);
    const [statusMessage, setStatusMessage] = useState("");
    const [isLoading, setIsLoading] = useState(false);
    const [isPlaying, setIsPlaying] = useState(Spicetify.Player.isPlaying());
    const [trackOffsetMs, setTrackOffsetMs] = useState(0);
    // 헬퍼 모드 관련 상태
    const [useHelper, setUseHelper] = useState(false);
    const [helperVideoUrl, setHelperVideoUrl] = useState(null);
    const containerRef = useRef(null);
    const playerRef = useRef(null); // Use ref to hold player instance for reliable cleanup
    const videoRef = useRef(null); // HTML5 video element for helper mode
    const abortDownloadRef = useRef(null); // abort function for helper download
    const brightnessValue = Math.min(Math.max(Number(brightness) || 0, 0), 100);
    const brightnessRatio = brightnessValue / 100;
    const blurValue = Math.min(Math.max(Number(blurAmount) || 0, 0), 80);
    const useCoverMode = coverMode === true;

    // 헬퍼 모드 설정 확인
    useEffect(() => {
        const helperEnabled = CONFIG?.visual?.["video-helper-enabled"] === true || CONFIG?.visual?.["video-helper-enabled"] === "true";
        setUseHelper(helperEnabled);
        
        // 설정 변경 이벤트 리스너
        const handleHelperChange = (e) => {
            setUseHelper(e.detail?.enabled === true);
            // 모드 전환 시 상태 초기화
            setHelperVideoUrl(null);
            setIsPlayerReady(false);
        };
        window.addEventListener("ivLyrics:videoHelperChanged", handleHelperChange);
        return () => window.removeEventListener("ivLyrics:videoHelperChanged", handleHelperChange);
    }, []);

    // 외부에서 전달된 videoInfo가 있으면 사용
    useEffect(() => {
        if (externalVideoInfo && externalVideoInfo.youtubeVideoId) {
            console.log(`[VideoBackground] Using external video info:`, externalVideoInfo);
            setVideoInfo(externalVideoInfo);
            setStatusMessage("");
            setIsLoading(false);
        }
    }, [externalVideoInfo]);

    // Load YouTube IFrame API (헬퍼 모드가 아닐 때만)
    useEffect(() => {
        if (useHelper) return;
        if (!window.YT) {
            const tag = document.createElement("script");
            tag.src = "https://www.youtube.com/iframe_api";
            const firstScriptTag = document.getElementsByTagName("script")[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        }
    }, [useHelper]);

    // Monitor Spotify Playback State
    useEffect(() => {
        const updateState = () => setIsPlaying(Spicetify.Player.isPlaying());
        Spicetify.Player.addEventListener("onplaypause", updateState);
        return () => Spicetify.Player.removeEventListener("onplaypause", updateState);
    }, []);

    // Fetch Video Info & Manage Player Lifecycle
    useEffect(() => {
        if (!trackUri) return;

        // 외부에서 전달된 videoInfo가 있으면 fetch 스킵
        if (externalVideoInfo && externalVideoInfo.youtubeVideoId) {
            return;
        }

        // Cleanup previous player immediately when track changes
        if (playerRef.current) {
            try {
                playerRef.current.destroy();
            } catch (e) { }
            playerRef.current = null;
        }

        const trackId = trackUri.split(":")[2];
        setStatusMessage(I18n.t("videoBackground.loading"));
        setVideoInfo(null);
        setIsPlayerReady(false);
        setIsLoading(true);

        let isMounted = true;

        // 비동기 로드 함수
        const loadVideoInfo = async () => {
            // 1. IndexedDB에서 사용자가 선택한 영상이 있는지 먼저 확인
            try {
                const savedVideo = await Utils.getSelectedVideo(trackUri);
                if (savedVideo && savedVideo.youtubeVideoId && isMounted) {
                    console.log(`[VideoBackground] Using saved selected video: ${savedVideo.youtubeVideoId}`);
                    setIsLoading(false);
                    setVideoInfo({
                        youtubeVideoId: savedVideo.youtubeVideoId,
                        youtubeTitle: savedVideo.youtubeTitle,
                        captionStartTime: savedVideo.captionStartTime,
                        communityEntryId: savedVideo.communityEntryId,
                        isAutoGenerated: savedVideo.isAutoGenerated
                    });
                    setStatusMessage("");
                    return;
                }
            } catch (e) {
                console.error('[VideoBackground] Failed to load saved video:', e);
            }

            // 2. 프리페치된 비디오 정보가 있는지 확인
            const prefetchedInfo = typeof Prefetcher !== 'undefined' ? Prefetcher.getVideoInfo(trackUri) : null;

            if (prefetchedInfo && isMounted) {
                // 프리페치된 데이터 사용
                console.log(`[VideoBackground] Using prefetched video info for trackId: ${trackId}`);
                setIsLoading(false);
                setVideoInfo(prefetchedInfo);
                setStatusMessage("");
                return;
            }

            // 2.5. SongDataService에서 통합 데이터 가져오기 (캐시가 없으면 서버에서 fetch)
            // 이렇게 하면 youtube 엔드포인트에 별도 요청하지 않아도 됨
            let songDataCached = window.SongDataService?.getCachedData(trackId);
            if (!songDataCached && window.SongDataService) {
                try {
                    songDataCached = await window.SongDataService.getSongData(trackUri);
                } catch (e) {
                    console.warn('[VideoBackground] SongDataService fetch failed:', e);
                }
            }

            if (songDataCached?.youtube && isMounted) {
                console.log(`[VideoBackground] Using SongDataService cached YouTube info for trackId: ${trackId}`);
                // 캐시 히트 로깅
                if (window.ApiTracker) {
                    window.ApiTracker.logCacheHit('youtube', `songdata:${trackId}`, {
                        videoId: songDataCached.youtube.videoId,
                        hasCaption: songDataCached.youtube.captionStartTime != null
                    });
                }
                setIsLoading(false);
                setVideoInfo({
                    youtubeVideoId: songDataCached.youtube.videoId,
                    captionStartTime: songDataCached.youtube.captionStartTime,
                    captionLanguage: songDataCached.youtube.captionLanguage,
                    totalCaptions: songDataCached.youtube.totalCaptions
                });
                setStatusMessage("");
                return;
            }

            // 3. 로컬 캐시 확인 (IndexedDB)
            try {
                const cachedYouTube = await LyricsCache.getYouTube(trackId);
                if (cachedYouTube && isMounted) {
                    console.log(`[VideoBackground] Using cached YouTube info for trackId: ${trackId}`);
                    // 캐시 히트 로깅
                    if (window.ApiTracker) {
                        window.ApiTracker.logCacheHit('youtube', `youtube:${trackId}`, {
                            videoId: cachedYouTube.youtubeVideoId,
                            hasCaption: cachedYouTube.captionStartTime != null
                        });
                    }
                    setIsLoading(false);
                    setVideoInfo(cachedYouTube);
                    setStatusMessage("");
                    return;
                }
            } catch (e) {
                console.warn('[VideoBackground] Cache check failed:', e);
            }

            // 4. 캐시가 없으면 API 호출 (커뮤니티 우선)
            try {
                const userHash = Utils.getUserHash();
                const youtubeUrl = `https://lyrics.api.ivl.is/lyrics/youtube?trackId=${trackId}&userHash=${userHash}&useCommunity=true`;

                // API 요청 로깅
                let logId = null;
                if (window.ApiTracker) {
                    logId = window.ApiTracker.logRequest('youtube', youtubeUrl, { trackId, userHash });
                }

                const res = await fetch(youtubeUrl);
                const data = await res.json();

                if (!isMounted) return;
                setIsLoading(false);
                if (data.success) {
                    // 성공 로깅
                    if (window.ApiTracker && logId) {
                        window.ApiTracker.logResponse(logId, {
                            videoId: data.data?.youtubeVideoId,
                            hasCaption: data.data?.captionStartTime != null
                        }, 'success');
                    }
                    // 로컬 캐시에 저장
                    LyricsCache.setYouTube(trackId, data.data).catch(() => { });
                    setVideoInfo(data.data);
                    setStatusMessage("");
                } else {
                    // 실패 로깅
                    if (window.ApiTracker && logId) {
                        window.ApiTracker.logResponse(logId, null, 'error', 'Video not found');
                    }
                    setStatusMessage(I18n.t("videoBackground.notFound"));
                    setVideoInfo(null);
                }
            } catch (e) {
                if (!isMounted) return;
                setIsLoading(false);
                setStatusMessage(I18n.t("videoBackground.error"));
                setVideoInfo(null);
            }
        };

        loadVideoInfo();

        return () => {
            isMounted = false;
            // Cleanup on unmount or track change
            if (playerRef.current) {
                try {
                    playerRef.current.destroy();
                } catch (e) { }
                playerRef.current = null;
            }
        };
    }, [trackUri]);

    // Track-specific sync offset handling
    useEffect(() => {
        if (!trackUri || typeof Utils === "undefined" || typeof Utils.getTrackSyncOffset !== "function") {
            setTrackOffsetMs(0);
            return undefined;
        }

        let isMounted = true;

        const loadOffset = async () => {
            try {
                const offset = (await Utils.getTrackSyncOffset(trackUri)) || 0;
                if (isMounted) {
                    setTrackOffsetMs(offset);
                }
            } catch (error) {
                if (isMounted) {
                    setTrackOffsetMs(0);
                }
            }
        };

        loadOffset();

        const handleOffsetChange = (event) => {
            if (event?.detail?.trackUri === trackUri) {
                setTrackOffsetMs(event.detail.offset || 0);
            }
        };

        window.addEventListener('ivLyrics:offset-changed', handleOffsetChange);

        return () => {
            isMounted = false;
            window.removeEventListener('ivLyrics:offset-changed', handleOffsetChange);
        };
    }, [trackUri]);

    // 헬퍼 모드: 비디오 다운로드 요청
    useEffect(() => {
        if (!useHelper || !videoInfo || !videoInfo.youtubeVideoId) return;

        // 기존 다운로드 중단
        if (abortDownloadRef.current) {
            abortDownloadRef.current();
            abortDownloadRef.current = null;
        }

        // 이전 상태 초기화
        setHelperVideoUrl(null);
        setIsPlayerReady(false);

        const videoId = videoInfo.youtubeVideoId;
        console.log(`[VideoBackground] Helper mode: requesting video ${videoId}`);

        // 1.5초 이내 응답 시 toast 숨기기 위한 변수
        const requestStartTime = Date.now();
        // 1.5초 후에 "준비 중" toast 표시 (progress toast가 먼저 뜨면 취소됨)
        let preparingToastTimeout = setTimeout(() => {
            Toast.progress(I18n.t("videoBackground.preparing"), 0);
        }, 1500);

        // 먼저 비디오 상태 확인
        const requestVideo = async () => {
            try {
                // 헬퍼 서버 연결 확인
                const isAvailable = await VideoHelperService.isHelperAvailable();
                if (!isAvailable) {
                    clearTimeout(preparingToastTimeout);
                    setStatusMessage(I18n.t("videoBackground.helperNotConnected"));
                    Toast.error(I18n.t("videoBackground.helperNotConnected"));
                    return;
                }

                // Helper 메시지를 번역된 텍스트로 변환하는 함수
                const translateHelperMessage = (message) => {
                    if (!message) return null;

                    // cookies.txt 파일 관련 메시지
                    if (message.includes("Trying with cookies.txt")) {
                        return I18n.t("videoBackground.tryingCookiesFile");
                    }
                    if (message.includes("Checking video with cookies.txt")) {
                        return I18n.t("videoBackground.checkingWithCookiesFile");
                    }

                    // 브라우저 쿠키 관련 메시지
                    const tryingBrowserMatch = message.match(/Trying with (\w+) cookies/);
                    if (tryingBrowserMatch) {
                        return I18n.t("videoBackground.tryingBrowserCookies", { browser: tryingBrowserMatch[1] });
                    }
                    const checkingBrowserMatch = message.match(/Checking video with (\w+) cookies/);
                    if (checkingBrowserMatch) {
                        return I18n.t("videoBackground.checkingWithBrowserCookies", { browser: checkingBrowserMatch[1] });
                    }

                    // 일반 확인 메시지
                    if (message.includes("Checking video availability")) {
                        return I18n.t("videoBackground.checkingAvailability");
                    }

                    // 연령 제한 관련 에러 메시지
                    if (message.includes("Age-restricted") || message.includes("age-restricted")) {
                        if (message.includes("No cookies.txt or supported browsers")) {
                            return I18n.t("videoBackground.ageRestrictedNoCookies");
                        }
                        return I18n.t("videoBackground.ageRestrictedFailed");
                    }

                    // 이미 다운로드된 영상
                    if (message.includes("Video already downloaded") || message.includes("Video already available")) {
                        return I18n.t("videoBackground.videoAlreadyDownloaded");
                    }

                    // 다운로드 중 메시지 (퍼센트 추출)
                    const downloadingMatch = message.match(/Downloading:\s*([\d.]+)%/);
                    if (downloadingMatch) {
                        return I18n.t("videoBackground.downloading", { percent: Math.round(parseFloat(downloadingMatch[1])) });
                    }

                    // 기본값: 원본 메시지 반환
                    return message;
                };

                // 비디오 요청 (SSE 스트림)
                abortDownloadRef.current = VideoHelperService.requestVideo(videoId, {
                    onProgress: (progress) => {
                        // progress 이벤트가 오면 preparing timeout 취소
                        clearTimeout(preparingToastTimeout);

                        const percent = Math.round(progress.percent || 0);
                        const translatedMsg = translateHelperMessage(progress.message);

                        if (progress.status === "downloading") {
                            Toast.progress(I18n.t("videoBackground.downloading", { percent }), percent);
                        } else if (progress.status === "processing") {
                            Toast.progress(I18n.t("videoBackground.processing"), 100);
                        } else if (progress.status === "checking") {
                            // checking 상태일 때 메시지가 있으면 번역된 메시지 사용
                            const checkingMsg = translatedMsg || I18n.t("videoBackground.checking");
                            Toast.progress(checkingMsg, 0);
                        }
                    },
                    onComplete: (url) => {
                        clearTimeout(preparingToastTimeout);
                        Toast.dismissProgress();
                        console.log(`[VideoBackground] Helper: video ready, setting URL: ${url}`);

                        // URL 유효성 확인
                        if (!url || typeof url !== 'string' || !url.startsWith('http')) {
                            console.error(`[VideoBackground] Invalid video URL received: ${url}`);
                            setStatusMessage(I18n.t("videoBackground.helperError"));
                            Toast.error(I18n.t("videoBackground.helperError"));
                            return;
                        }

                        setHelperVideoUrl(url);
                        setStatusMessage("");

                        // 1.5초 이내로 완료되면 완료 toast도 숨김
                        const elapsed = Date.now() - requestStartTime;
                        if (elapsed > 1500) {
                            Toast.success(I18n.t("videoBackground.downloadComplete"));
                        }
                    },
                    onError: (message) => {
                        clearTimeout(preparingToastTimeout);
                        Toast.dismissProgress();
                        console.error(`[VideoBackground] Helper error: ${message}`);

                        // 에러 메시지 번역
                        const translatedError = translateHelperMessage(message) || I18n.t("videoBackground.helperError");
                        setStatusMessage(translatedError);
                        Toast.error(translatedError);
                    },
                });
            } catch (e) {
                clearTimeout(preparingToastTimeout);
                console.error("[VideoBackground] Helper request failed:", e);
                setStatusMessage(I18n.t("videoBackground.helperError"));
            }
        };

        requestVideo();

        return () => {
            clearTimeout(preparingToastTimeout);
            Toast.dismissProgress(); // 컴포넌트 언마운트 시 progress toast 닫기
            if (abortDownloadRef.current) {
                abortDownloadRef.current();
                abortDownloadRef.current = null;
            }
        };
    }, [useHelper, videoInfo]);

    // 헬퍼 모드: HTML5 video 재생 및 동기화
    useEffect(() => {
        if (!useHelper || !helperVideoUrl || !videoRef.current) return;

        console.log(`[VideoBackground] Loading helper video from: ${helperVideoUrl}`);
        
        const video = videoRef.current;
        video.src = helperVideoUrl;
        video.muted = true;
        video.loop = false;

        const handleCanPlay = () => {
            // 영상이 준비되면 즉시 현재 Spotify 위치로 동기화
            if (videoInfo) {
                const spotifyTime = Spicetify.Player.getProgress() / 1000;
                const lyricsStartTime = (firstLyricTime || 0) / 1000;
                const captionStartTime = videoInfo.captionStartTime;
                const offset = (captionStartTime !== null && captionStartTime !== undefined)
                    ? (captionStartTime - lyricsStartTime)
                    : 0;
                const globalDelayMs = typeof CONFIG !== "undefined" && CONFIG.visual ? Number(CONFIG.visual.delay || 0) : 0;
                const additionalDelaySeconds = (trackOffsetMs + globalDelayMs) / 1000;
                let targetVideoTime = spotifyTime + offset + additionalDelaySeconds;
                
                if (targetVideoTime >= 0 && video.duration > 0) {
                    if (targetVideoTime >= video.duration) {
                        targetVideoTime = targetVideoTime % video.duration;
                    }
                }
                
                if (targetVideoTime >= 0) {
                    video.currentTime = targetVideoTime;
                }
            }
            
            setIsPlayerReady(true);
            if (Spicetify.Player.isPlaying()) {
                video.play().catch(() => { });
            }
        };

        const handleError = (e) => {
            console.error("[VideoBackground] Helper video error:", e, "src:", video.src);
            setStatusMessage(I18n.t("videoBackground.helperError"));
            setIsPlayerReady(false);
        };

        video.addEventListener('canplay', handleCanPlay);
        video.addEventListener('error', handleError);
        video.addEventListener('loadstart', () => console.log("[VideoBackground] Video loadstart"));
        video.addEventListener('loadedmetadata', () => console.log("[VideoBackground] Video loadedmetadata, duration:", video.duration));

        video.load();

        return () => {
            video.removeEventListener('canplay', handleCanPlay);
            video.removeEventListener('error', handleError);
        };
    }, [useHelper, helperVideoUrl, videoInfo, firstLyricTime, trackOffsetMs]);

    // 헬퍼 모드: 동기화 로직
    useEffect(() => {
        if (!useHelper || !videoRef.current || !isPlayerReady || !videoInfo) return;

        const video = videoRef.current;

        const syncInterval = setInterval(() => {
            const spotifyIsPlaying = Spicetify.Player.isPlaying();

            if (spotifyIsPlaying !== isPlaying) {
                setIsPlaying(spotifyIsPlaying);
            }

            if (!spotifyIsPlaying) {
                if (!video.paused) {
                    video.pause();
                }
                return;
            } else {
                if (video.paused) {
                    video.play().catch(() => { });
                }
            }

            const spotifyTime = Spicetify.Player.getProgress() / 1000;
            const lyricsStartTime = (firstLyricTime || 0) / 1000;
            const captionStartTime = videoInfo.captionStartTime;

            const offset = (captionStartTime !== null && captionStartTime !== undefined)
                ? (captionStartTime - lyricsStartTime)
                : 0;
            const globalDelayMs = typeof CONFIG !== "undefined" && CONFIG.visual ? Number(CONFIG.visual.delay || 0) : 0;
            const additionalDelaySeconds = (trackOffsetMs + globalDelayMs) / 1000;
            let targetVideoTime = spotifyTime + offset + additionalDelaySeconds;

            // 영상 길이보다 음악이 길 경우, 영상을 처음부터 반복 재생
            if (targetVideoTime >= 0 && video.duration > 0) {
                if (targetVideoTime >= video.duration) {
                    targetVideoTime = targetVideoTime % video.duration;
                }
            }

            if (targetVideoTime >= 0) {
                const currentVideoTime = video.currentTime;
                if (Math.abs(currentVideoTime - targetVideoTime) > 0.5) {
                    video.currentTime = targetVideoTime;
                }
            }
        }, 500);

        return () => clearInterval(syncInterval);
    }, [useHelper, isPlayerReady, videoInfo, firstLyricTime, isPlaying, trackOffsetMs]);

    // 일반 모드 (YouTube IFrame): Initialize Player when videoInfo is available
    useEffect(() => {
        if (useHelper) return; // 헬퍼 모드면 스킵
        if (!videoInfo || !videoInfo.youtubeVideoId || !containerRef.current) return;

        // Double check cleanup
        if (playerRef.current) {
            try {
                playerRef.current.destroy();
            } catch (e) { }
            playerRef.current = null;
        }

        const initPlayer = () => {
            if (!window.YT || !window.YT.Player) {
                setTimeout(initPlayer, 100);
                return;
            }

            // Ensure container is empty before creating new player
            // containerRef.current.innerHTML = ""; // YT.Player replaces the element, so we need a wrapper or let it replace a child. 
            // Actually YT.Player replaces the target element. If we use a ref to a div, that div gets replaced by the iframe.
            // If we destroy the player, does it restore the div? No.
            // So we need to ensure we have a fresh target element.
            // The easiest way is to let React handle the DOM node. 
            // If we destroy the player, the iframe is removed. We might need to recreate the container div?
            // Actually, YT.Player(id|element) replaces the element. 
            // If we use a ref, we should probably use a wrapper and append a child to it, or handle the ref carefully.

            // Better approach: Create a temporary div inside the container
            const playerDiv = document.createElement('div');
            containerRef.current.innerHTML = ''; // Clear container
            containerRef.current.appendChild(playerDiv);

            const newPlayer = new window.YT.Player(playerDiv, {
                height: "100%",
                width: "100%",
                videoId: videoInfo.youtubeVideoId,
                playerVars: {
                    autoplay: 1,
                    controls: 0,
                    disablekb: 1,
                    fs: 0,
                    rel: 0,
                    iv_load_policy: 3,
                    mute: 1,
                    origin: window.location.origin,
                },
                events: {
                    onReady: (event) => {
                        playerRef.current = event.target;
                        setIsPlayerReady(true);
                        event.target.mute();
                        event.target.playVideo();
                    },
                },
            });
            // Note: playerRef.current is set in onReady, but we can also set it here if newPlayer returns the instance immediately.
            // YT.Player returns the object immediately.
            playerRef.current = newPlayer;
        };

        initPlayer();

    }, [useHelper, videoInfo]);

    // 일반 모드 (YouTube IFrame): Sync Logic
    useEffect(() => {
        if (useHelper) return; // 헬퍼 모드면 스킵
        // We use playerRef.current here
        const syncInterval = setInterval(() => {
            const player = playerRef.current;
            if (!player || !isPlayerReady || !videoInfo) return;
            // Check if player has methods (sometimes it's not fully ready even if object exists)
            if (typeof player.getPlayerState !== 'function') return;

            const spotifyIsPlaying = Spicetify.Player.isPlaying();

            if (spotifyIsPlaying !== isPlaying) {
                setIsPlaying(spotifyIsPlaying);
            }

            if (!spotifyIsPlaying) {
                if (player.getPlayerState() === 1) { // Playing
                    player.pauseVideo();
                }
                return;
            } else {
                if (player.getPlayerState() !== 1) {
                    player.playVideo();
                }
            }

            const spotifyTime = Spicetify.Player.getProgress() / 1000;
            const lyricsStartTime = (firstLyricTime || 0) / 1000;
            const captionStartTime = videoInfo.captionStartTime;

            // captionStartTime이 null이면 (자막이 없는 영상) 오프셋 계산 없이 Spotify 시간을 그대로 사용
            // captionStartTime이 있는 경우에만 가사와 자막 시작 시간 차이를 계산하여 오프셋 적용
            const offset = (captionStartTime !== null && captionStartTime !== undefined)
                ? (captionStartTime - lyricsStartTime)
                : 0;
            const globalDelayMs = typeof CONFIG !== "undefined" && CONFIG.visual ? Number(CONFIG.visual.delay || 0) : 0;
            const additionalDelaySeconds = (trackOffsetMs + globalDelayMs) / 1000;
            let targetVideoTime = spotifyTime + offset + additionalDelaySeconds;

            // 영상 길이보다 음악이 길 경우, 영상을 처음부터 반복 재생
            // getDuration()은 영상의 총 길이(초)를 반환
            if (targetVideoTime >= 0 && typeof player.getDuration === 'function') {
                const videoDuration = player.getDuration();
                // 영상 길이가 0보다 크고, 목표 시간이 영상 길이를 초과하면 모듈로 연산
                if (videoDuration > 0 && targetVideoTime >= videoDuration) {
                    targetVideoTime = targetVideoTime % videoDuration;
                }
            }

            if (targetVideoTime >= 0) {
                const currentVideoTime = player.getCurrentTime();
                if (Math.abs(currentVideoTime - targetVideoTime) > 0.5) {
                    player.seekTo(targetVideoTime, true);
                }
            }
        }, 500);

        return () => clearInterval(syncInterval);
    }, [isPlayerReady, videoInfo, firstLyricTime, isPlaying, trackOffsetMs]);

    // Render Album Art Background (Fallback)
    const renderFallback = () => {
        const albumArtUrl =
            Spicetify.Player.data?.item?.metadata?.image_xlarge_url ||
            Spicetify.Player.data?.item?.metadata?.image_large_url ||
            Spicetify.Player.data?.item?.metadata?.image_url;

        return react.createElement("div", {
            style: {
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                backgroundImage: albumArtUrl ? `url(${albumArtUrl})` : "none",
                backgroundSize: "cover",
                backgroundPosition: "center",
                filter: `brightness(${brightnessRatio}) blur(${blurValue}px)`,
                transform: "scale(1.1)",
                zIndex: 0,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
            },
        }, statusMessage ? react.createElement("div", {
            style: {
                color: "white",
                fontSize: "24px",
                fontWeight: "bold",
                textShadow: "0 2px 4px rgba(0,0,0,0.5)",
                zIndex: 10,
                background: "rgba(0,0,0,0.3)",
                padding: "20px",
                borderRadius: "10px",
                backdropFilter: "blur(10px)"
            }
        }, statusMessage) : null);
    };

    // 헬퍼 모드용 video 태그 스타일
    const helperVideoStyle = {
        position: "absolute",
        top: useCoverMode ? "50%" : 0,
        left: useCoverMode ? "50%" : 0,
        width: useCoverMode ? "177.78vh" : "100%",
        height: useCoverMode ? "56.25vw" : "100%",
        minWidth: useCoverMode ? "100%" : undefined,
        minHeight: useCoverMode ? "100%" : undefined,
        transform: useCoverMode
            ? `translate(-50%, -50%)${blurValue ? " scale(1.05)" : ""}`
            : (blurValue ? "scale(1.05)" : undefined),
        opacity: isPlayerReady && isPlaying ? 1 : 0,
        transition: "opacity 0.5s ease",
        zIndex: 1,
        pointerEvents: "none",
        filter: blurValue ? `blur(${blurValue}px)` : "none",
        objectFit: useCoverMode ? "cover" : "contain",
    };

    return react.createElement("div", {
        style: {
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            overflow: "hidden",
            zIndex: 0,
        }
    },
        // Loading indicator (top-left corner)
        isLoading && react.createElement("div", {
            style: {
                position: "absolute",
                top: "20px",
                left: "20px",
                zIndex: 100,
                display: "flex",
                alignItems: "center",
                gap: "12px",
                background: "rgba(0, 0, 0, 0.7)",
                backdropFilter: "blur(20px)",
                WebkitBackdropFilter: "blur(20px)",
                padding: "12px 18px",
                borderRadius: "12px",
                border: "1px solid rgba(255, 255, 255, 0.1)",
                boxShadow: "0 4px 20px rgba(0, 0, 0, 0.3)",
                animation: "fadeIn 0.3s ease",
            }
        },
            // Spinner
            react.createElement("div", {
                style: {
                    width: "18px",
                    height: "18px",
                    border: "2px solid rgba(255, 255, 255, 0.2)",
                    borderTopColor: "#1DB954",
                    borderRadius: "50%",
                    animation: "spin 1s linear infinite",
                }
            }),
            react.createElement("span", {
                style: {
                    color: "white",
                    fontSize: "13px",
                    fontWeight: "500",
                    fontFamily: "Pretendard Variable, -apple-system, sans-serif",
                }
            }, I18n.t("videoBackground.loadingMessage"))
        ),
        // CSS animation keyframes
        isLoading && react.createElement("style", {
            dangerouslySetInnerHTML: {
                __html: `
                    @keyframes spin {
                        to { transform: rotate(360deg); }
                    }
                    @keyframes fadeIn {
                        from { opacity: 0; transform: translateY(-10px); }
                        to { opacity: 1; transform: translateY(0); }
                    }
                `
            }
        }),
        renderFallback(),
        // 헬퍼 모드: HTML5 video 태그
        useHelper && react.createElement("video", {
            ref: videoRef,
            style: helperVideoStyle,
            muted: true,
            playsInline: true,
            loop: false,
        }),
        // 일반 모드: YouTube IFrame 컨테이너
        !useHelper && react.createElement("div", {
            ref: containerRef,
            style: {
                position: "absolute",
                top: useCoverMode ? "50%" : 0,
                left: useCoverMode ? "50%" : 0,
                width: useCoverMode ? "177.78vh" : "100%", // 16:9 aspect ratio: 100vh * 16/9
                height: useCoverMode ? "56.25vw" : "100%", // 16:9 aspect ratio: 100vw * 9/16
                minWidth: useCoverMode ? "100%" : undefined,
                minHeight: useCoverMode ? "100%" : undefined,
                transform: useCoverMode
                    ? `translate(-50%, -50%)${blurValue ? " scale(1.05)" : ""}`
                    : (blurValue ? "scale(1.05)" : undefined),
                opacity: isPlayerReady && isPlaying ? 1 : 0, // Hide when paused or not ready
                transition: "opacity 0.5s ease",
                zIndex: 1,
                pointerEvents: "none",
                filter: blurValue ? `blur(${blurValue}px)` : "none",
            }
        }),
        react.createElement("div", {
            style: {
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                backgroundColor: "black",
                opacity: 1 - brightnessRatio,
                zIndex: 2,
                pointerEvents: "none"
            }
        })
    );
};

window.VideoBackground = VideoBackground;
